{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport { NativeAppEventEmitter } from \"react-native-web/dist/index\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport _ from 'lodash';\nimport async from 'async';\nimport EventEmitter from 'eventemitter3';\nimport MediaStates from \"./MediaStates\";\nvar RCTAudioRecorder = NativeModules.AudioRecorder;\nvar recorderId = 0;\nvar defaultRecorderOptions = {\n  autoDestroy: true\n};\n\nvar Recorder = function (_EventEmitter) {\n  _inherits(Recorder, _EventEmitter);\n\n  var _super = _createSuper(Recorder);\n\n  function Recorder(path) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRecorderOptions;\n\n    _classCallCheck(this, Recorder);\n\n    _this = _super.call(this);\n    _this._path = path;\n    _this._options = options;\n    _this._recorderId = recorderId++;\n\n    _this._reset();\n\n    var appEventEmitter = Platform.OS === 'ios' ? NativeAppEventEmitter : DeviceEventEmitter;\n    appEventEmitter.addListener('RCTAudioRecorderEvent:' + _this._recorderId, function (payload) {\n      _this._handleEvent(payload.event, payload.data);\n    });\n    return _this;\n  }\n\n  _createClass(Recorder, [{\n    key: \"_reset\",\n    value: function _reset() {\n      this._state = MediaStates.IDLE;\n      this._duration = -1;\n      this._position = -1;\n      this._lastSync = -1;\n    }\n  }, {\n    key: \"_updateState\",\n    value: function _updateState(err, state) {\n      this._state = err ? MediaStates.ERROR : state;\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function _handleEvent(event, data) {\n      switch (event) {\n        case 'ended':\n          this._state = Math.min(this._state, MediaStates.PREPARED);\n          break;\n\n        case 'info':\n          break;\n\n        case 'error':\n          this._reset();\n\n          break;\n      }\n\n      this.emit(event, data);\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare() {\n      var _this2 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _.noop;\n\n      this._updateState(null, MediaStates.PREPARING);\n\n      RCTAudioRecorder.prepare(this._recorderId, this._path, this._options, function (err, fsPath) {\n        _this2._fsPath = fsPath;\n\n        _this2._updateState(err, MediaStates.PREPARED);\n\n        callback(err, fsPath);\n      });\n      return this;\n    }\n  }, {\n    key: \"record\",\n    value: function record() {\n      var _this3 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _.noop;\n      var tasks = [];\n\n      if (this._state === MediaStates.IDLE) {\n        tasks.push(function (next) {\n          _this3.prepare(next);\n        });\n      }\n\n      tasks.push(function (next) {\n        RCTAudioRecorder.record(_this3._recorderId, next);\n      });\n      async.series(tasks, function (err) {\n        _this3._updateState(err, MediaStates.RECORDING);\n\n        callback(err);\n      });\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this4 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _.noop;\n\n      if (this._state >= MediaStates.RECORDING) {\n        RCTAudioRecorder.stop(this._recorderId, function (err) {\n          _this4._updateState(err, MediaStates.DESTROYED);\n\n          callback(err);\n        });\n      } else {\n        setTimeout(callback, 0);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toggleRecord\",\n    value: function toggleRecord() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _.noop;\n\n      if (this._state === MediaStates.RECORDING) {\n        this.stop(function (err) {\n          callback(err, true);\n        });\n      } else {\n        this.record(function (err) {\n          callback(err, false);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _.noop;\n\n      this._reset();\n\n      RCTAudioRecorder.destroy(this._recorderId, callback);\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n  }, {\n    key: \"canRecord\",\n    get: function get() {\n      return this._state >= MediaStates.PREPARED;\n    }\n  }, {\n    key: \"canPrepare\",\n    get: function get() {\n      return this._state == MediaStates.IDLE;\n    }\n  }, {\n    key: \"isRecording\",\n    get: function get() {\n      return this._state == MediaStates.RECORDING;\n    }\n  }, {\n    key: \"isPrepared\",\n    get: function get() {\n      return this._state == MediaStates.PREPARED;\n    }\n  }, {\n    key: \"fsPath\",\n    get: function get() {\n      return this._fsPath;\n    }\n  }]);\n\n  return Recorder;\n}(EventEmitter);\n\nexport default Recorder;","map":{"version":3,"sources":["E:/WORK/React Native/MusicApp/node_modules/react-native-audio-toolkit/src/Recorder.js"],"names":["NativeAppEventEmitter","_","async","EventEmitter","MediaStates","RCTAudioRecorder","NativeModules","AudioRecorder","recorderId","defaultRecorderOptions","autoDestroy","Recorder","path","options","_path","_options","_recorderId","_reset","appEventEmitter","Platform","OS","DeviceEventEmitter","addListener","payload","_handleEvent","event","data","_state","IDLE","_duration","_position","_lastSync","err","state","ERROR","Math","min","PREPARED","emit","callback","noop","_updateState","PREPARING","prepare","fsPath","_fsPath","tasks","push","next","record","series","RECORDING","stop","DESTROYED","setTimeout","destroy"],"mappings":"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","sourcesContent":["'use strict';\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  NativeAppEventEmitter,\n  Platform\n} from 'react-native';\n\nimport _ from 'lodash';\nimport async from 'async';\nimport EventEmitter from 'eventemitter3';\nimport MediaStates from './MediaStates';\n\nvar RCTAudioRecorder = NativeModules.AudioRecorder;\n\nvar recorderId = 0;\n\nvar defaultRecorderOptions = {\n  autoDestroy: true\n};\n\n/**\n * Represents a media recorder\n * @constructor\n */\nclass Recorder extends EventEmitter {\n  constructor(path, options = defaultRecorderOptions) {\n    super();\n\n    this._path = path;\n    this._options = options;\n\n    this._recorderId = recorderId++;\n    this._reset();\n\n    let appEventEmitter = Platform.OS === 'ios' ? NativeAppEventEmitter : DeviceEventEmitter;\n\n    appEventEmitter.addListener('RCTAudioRecorderEvent:' + this._recorderId, (payload: Event) => {\n      this._handleEvent(payload.event, payload.data);\n    });\n  }\n\n  _reset() {\n    this._state = MediaStates.IDLE;\n    this._duration = -1;\n    this._position = -1;\n    this._lastSync = -1;\n  }\n\n  _updateState(err, state) {\n    this._state = err ? MediaStates.ERROR : state;\n  }\n\n  _handleEvent(event, data) {\n    //console.log('event: ' + event + ', data: ' + JSON.stringify(data));\n    switch (event) {\n      case 'ended':\n        this._state = Math.min(this._state, MediaStates.PREPARED);\n        break;\n      case 'info':\n        // TODO\n        break;\n      case 'error':\n        this._reset();\n        //this.emit('error', data);\n        break;\n    }\n\n    this.emit(event, data);\n  }\n\n  prepare(callback = _.noop) {\n    this._updateState(null, MediaStates.PREPARING);\n\n    // Prepare recorder\n    RCTAudioRecorder.prepare(this._recorderId, this._path, this._options, (err, fsPath) => {\n      this._fsPath = fsPath;\n      this._updateState(err, MediaStates.PREPARED);\n      callback(err, fsPath);\n    });\n\n    return this;\n  }\n\n  record(callback = _.noop) {\n    let tasks = [];\n\n    // Make sure recorder is prepared\n    if (this._state === MediaStates.IDLE) {\n      tasks.push((next) => {\n        this.prepare(next);\n      });\n    }\n\n    // Start recording\n    tasks.push((next) => {\n        RCTAudioRecorder.record(this._recorderId, next);\n    });\n\n    async.series(tasks, (err) => {\n      this._updateState(err, MediaStates.RECORDING);\n      callback(err);\n    });\n\n    return this;\n  }\n\n  stop(callback = _.noop) {\n    if (this._state >= MediaStates.RECORDING) {\n      RCTAudioRecorder.stop(this._recorderId, (err) => {\n        this._updateState(err, MediaStates.DESTROYED);\n        callback(err);\n      });\n    } else {\n      setTimeout(callback, 0);\n    }\n\n    return this;\n  }\n\n  toggleRecord(callback = _.noop) {\n    if (this._state === MediaStates.RECORDING) {\n      this.stop((err) => {\n        callback(err, true);\n      });\n    } else {\n      this.record((err) => {\n        callback(err, false);\n      });\n    }\n\n    return this;\n  }\n\n  destroy(callback = _.noop) {\n    this._reset();\n    RCTAudioRecorder.destroy(this._recorderId, callback);\n  }\n\n  get state()       { return this._state;                          }\n  get canRecord()   { return this._state >= MediaStates.PREPARED;  }\n  get canPrepare()  { return this._state == MediaStates.IDLE;      }\n  get isRecording() { return this._state == MediaStates.RECORDING; }\n  get isPrepared()  { return this._state == MediaStates.PREPARED;  }\n  get fsPath()      { return this._fsPath; }\n}\n\nexport default Recorder;\n"]},"metadata":{},"sourceType":"module"}